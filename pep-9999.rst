PEP: XXX
Title: Line number table specification
Author: Mark Shannon <mark@hotpy.org>
Status: Draft
Type: Enhancement
Content-Type: text/x-rst
Created: 09-Apr-2020
Post-History:

Abstract
========

Add a new ``co_lines`` method to the code object, which will return an iterator of
tuples describing the source code lines for bytecode.
Each tuple will constist of three items:

* Start bytecode offset (inclusive)
* End bytecode offset (exclusive)
* The line number or ``None`` if there is no source lines for the bytecode.

The start and end can be the same for source code with no bytecodes.

Motivation
==========


Tools needing to access line information for a code object are forced to use the ``co_lnotab``
bytes object. However, the format of that object is not well specified and can change without
warning as the bytecode format changes and new optimizations are added.
In addition ``sys.settrace`` tracing uses ``co_lnotab`` table to determine which events occur,
which makes it fragile.

By providing the new ``co_lines`` method, tools and ``sys.settrace`` tracing can expect 
a consistent interface that provides the necessary information regardless of optimizations in
the bytecode generator.

Rationale
=========

The format of start(inclusive), end(exclusive), line allows inclusion of lines without bytecode and
bytecodes without code.

Both of these can commonly occur in Python code.
For example, consider:

::

  def foo(a):
      if 1:    #line 1
          a    #line 2
    pass       #line 3

which translates to the bytecode:

::
 
  0:  LOAD_FAST (a)
  2:  POP_TOP
  4:  LOAD_CONST None
  6:  RETURN_VALUE

There are no bytecodes for line 1 or 3, and the bytecodes 4 and 6 do not have a matching source line.

Specification
=============

Code objects will gain a new method, ``co_lines`` with the following signature:

::

    def co_lines(self)->Iterator[Tuple[int, int, Optional[int]]:
        ...

Each tuple which consist of three parts, a start bytecode offset (inclusive), an end offset (exclusive) and an optional line number.

Hereafter, the term "line number table" refers to the list of tuples generated by ``list(code.co_lines())``.

Line events for tracing.
------------------------

Currently when tracing is active, an event occurs every time a new line of code is entered.
However, optimizations may cause some lines to be lost. There are various workarounds in CPython
to minimize the impact of these changes, but the exact sequence of events does change from version to version.

This PEP requires than events are generated for all source code that would be executed by a naive interpreter even though
there may not be any bytecode for that source code. To do so, all reachable lines of source must be present in the line number
table. If there are no bytecodes, the start and end offset should be the same.

Backwards Compatibility
=======================

The ``co_lnotab`` attribute will remain, although it will be lazily generated if needed.
More events may occur when tracing is active, but those should be more consistent with the source code.

Implementation
========================

Internal representation
-----------------------

Since the end offset of one tuple is the same as the start offset of the next, the tuples can be stored as pairs: offset, line.
Also given that the first tuple must have a start offset of zero, and we can use the co_firstline as an implicit start line, each tuple
can stored as a delta. We can reuse the encoding currently used for ``co_lnotab`` to store the table compactly.
Two changes to the format are needed:
A line delta of -128 represents that the line for this chunk is ``None`` and there is no change to the underlying line number.
Byte code deltas of 0 are allowed for any line delta.

Compiler implementation
-----------------------

The front end should always generate instructions for source code. If no bytecodes are needed, a ``NOP`` instruction can be emitted.
Likewise, the bytecode optimizer should not eliminate bytecodes, but replace them with ``NOP``\s.
Durind CFG linearization and offset computation, ``NOP``\s should be treated as having size 0.
Final code and line number table generation can then skip ``NOP``\s, treating them as zero sized instructions.

Example
~~~~~~~

Python code:

::

  def foo(a):
      if 1:    #line 1
          a    #line 2
      pass     #line 3

Code generated by from end:

::
 
  0:  LOAD_CONST (1)           # Line 1
  2:  POP_JUMP_IF_FALSE (to 8) # Line 1
  4:  LOAD_FAST (a)            # Line 2
  6:  POP_TOP                  # Line 2
  8:  NOP                      # Line 3
  10: LOAD_CONST None          # Line None
  12: RETURN_VALUE             # Line None

Optimized code:

::
 
  0:  NOP                      # Line 1
  2:  NOP                      # Line 1
  4:  LOAD_FAST (a)            # Line 2
  6:  POP_TOP                  # Line 2
  8:  NOP                      # Line 3
  10: LOAD_CONST None          # Line None
  12: RETURN_VALUE             # Line None

Generated code:

::

  0:  LOAD_FAST (a)
  2:  POP_TOP
  4:  LOAD_CONST None
  6:  RETURN_VALUE

Line number table:

=======  =====  =======
 Start    End    Line
=======  =====  =======
   0       0       1
   0       4       2
   4       4       3
   4       6     None
=======  =====  =======


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
